세션의 고유정보들도 보호해줘야함. id/pw 같은것.
멤버변수로해서 완전 소유로 한다면 자식이 사용할수 있도록 열쇠를 protected
 
방법 2 상속의 방법으로 쓸때 어떨때 쓸수 있냐면 
세션이 동접자 100명일때 100개의 열쇠.
매니저마다 열쇠 만들어지고
이때 특정 클래스로 만들어진 객체들은 열쇠하나를 공유하게 하고 싶다는 경우가 있을 수 있다.
static 이다.
클래스를 하나 만들어서 해야함
기존의 lockguard는 파라미터로 받아오는데 그걸 좀 변형해서 
lockguard에서 static으로 lock클래스 객체를 소유.
이 클래스로 만들어진 객체는 하나의 열쇠만을 공유한다.
내부클래스로 lockguard를 넣어놓자.
class lockguard
{
friend lock_guard;
 public:
         class lock_guard
         {
          생성자(){lockguard::key.lock()}
           소멸자 () {lockguard::key.unlock()}
         }
private:
static key;
}

동일한 클래스가 하나의 열쇠를 소유할거라면 socket에 lockgaurd을 상속하면 된다.
템플릿으로 바꿔서 사용가능.

mutex 안쓰고 criticalsection 쓰는 이유는 소유권이 os에있고 아니고 차이인데
우리가 소유하고 쓰는 핸들이면 더 빠르기 때문에
하지만 리눅스 같은건 프로세스 중심이라 cpu 스케쥴링 하는 방식이 다르다.
리눅스는 mutex로 한다.

c++ 라이브러리가 제공하는  mutex는 말만 뮤텍스지 안에서는 criticalsection으로 되어있다.
(windows에서는)

이제부터 바꿀거는 문자열 멀티바이트로 했는데 유니코드로 바꾼다.
char* 를 Byte*로 바꿔도 된다.
문자열 다루는거는 wchar_t로 바꾼다. 유니코드로 저장할때 쓰는 타입.(2byte 짜리 영문이든 한글이든)
tchar 써도 됨. 호환형 변수 설정을 유니코드로 하면 유니코드로 받아오고 멀티바이트로 하면 멀티바이트로 받아옴.
알아두기 utf8은 가변으로 바뀌는 유니코드임.


