디자인 패턴이란?:: 객체지향 프로그래밍에서 공통적인 디자인 문제를 찾아내고 해결하는 가이드라인, 추상적인 것

디자인 패턴을 사용하는 이유?:: 공통적인 소프트웨어 디자인 문제를 해결하는데 도움이 될 수 있어서

---------
생성패턴- 클래스 선택 및 객체 생성을 관리 위한 패턴

싱글톤:: 인스턴스 개수가 최대 한 개를 넘지 않도록 하는 패턴
싱글톤 vs 정적 메소드 :: 상속과 인터페이스(객체라) / 다수 객체로 전환가능(싱글톤탈출) / 동적 바인딩(컴파일시x 런타임o)
단점:: 멀티 스레드환경에서는 메소드 동기화떔에 엑세스가 느려짐, 초기화 시간떔에 구동 시간이 느려짐, 자원을 오래 점유 할 수 있음

빌더:: 객체가 어떤 식으로 구축되는지 모르는 상황에서 단계별로 객체를 생성하는 패턴
장점:: 초기화 과정이 훨씬 깔끔하고 이해하기 좋음, 초기화 매개변수를 추가하거나 제거하기도 편함,
생성이 복잡하거나 몇 단계를 거쳐서 생성해야 할 때 -> 빌더 / 다른경우-> 추상 팩토리

팩토리 메소드:: 새 객체를 만들어서 리턴하기 위한 용도로 만들어진 클래스 계층구조
베이스 클래스에선 서브클래스에서 오버라이드할 팩토리 메소드 정의-> 새 객체 생성되는 방법은 서브클래스에서 결정

추상 팩토리:: 추상팩토리는 팩토리의 구현과 그 팩토리가 사용하는 코드를 갈라주는 패턴
::관련이 있는 객체들을 통째로 묶어 팩토리 클래스로 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴-
추상 클래스로부터 상속된 일련의 팩토리 클래스로 구현. 여러 팩토리 중에서 어떤것을 사용할지 결정하고 나면 추상클래스를 통해 팩토리 참조
프로그램이 실행되는 도중에 다른 팩토리를 선택하는것도 가능 (팩토리 메소드 패턴을 좀 더 캡슐화)


팩토리 클래스가 하나 밖에 없을떄는 추상 팩토리 패턴을 사용 안함

-------------------
행위,행위 패턴- 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의하는 패턴

커맨드:: 요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴

반복자:: 접근기능과 자료구조를 분리시켜서 객체화하며 서로 다른 구조를 가지고 있는 저장 객체에 대해 접근하기 위해 인터페이스를 통일시킬떄 사용하는 패턴

옵저버:: 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존관계를 구성하는 패턴

상태:: 객체 내부의 상태가 변경될 때 행동을 변경하도록 허락함, 객체는 자신의 클래스가 변경되는 것처럼 보이는 패턴

전략:: 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 행위를 수정하지 않고 전략을 바꿔주기만 함으로써 유연하게 확장하는 패턴

템플릿 메소드:: 작업을 처리하는 일부분을 서브 클래스로 캡슐화하는 패턴
전체적으로 동일하면서 부분적으로 다른 구문으로 구성된 메소드의 코드 중복을 최소화

비지터(방문자):: 데이터 구조와 기능을 분리하여 데이터 구조의 원소들을 변경하지 않고 새로운 기능을 추가 가능한 패턴

컴포지트:: 객체와 구성을 트리로 구성하여 하나의 인터페이스에서 사용하도록 고려한 패턴
------------------
구조 패턴- 클래스와 객체 사이의 관계를 구성하는 범주의 패턴, 서로 연관된 객체를 함께 사용하여 원하는 일을 하기위한 가이드라인

데코레이션:: 주어진 상황 및 용도에 따라 어떤 객체를 책임을 덧붙이는 패턴(기능확장 + 서브클래스 대신)

브리지:: 구현부에 추상층을 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴

컴포지트:: 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴

프록시:: 어떤 객체롤 접근하는 것을 통제하기 위개 그 객체의 자리 채움자를 제공하는 패턴
-----------------


